<h2 id="아키텍처-재구성">아키텍처 재구성</h2>
<p>이전 포스트에 기재한 지금까지의 문제들을 다시 한번 정리해보자.</p>
<ol>
<li><strong>S3 재귀 호출 문제</strong> - 이미지를 최적화하고 같은 버킷에 업로드하면 Lambda가 무한으로 호출된다.</li>
<li><strong>파일 이름 불일치 문제</strong> - Spring 서버는 Lambda의 이미지 경량화 성공 여부와 최종 파일명을 알 수 없다.</li>
</ol>
<p>이 문제들을 해결하기 위해 다음과 같이 아키텍처를 새로 구성했다.
<img alt="" src="https://velog.velcdn.com/images/ysj7191/post/daba5d84-d200-478e-8974-8029a7314c4e/image.png" /></p>
<blockquote>
<ol>
<li><code>유저</code>가 POST /file API를 통해 이미지 업로드 요청을 보낸다.</li>
<li><code>서버</code>는 요청받은 이미지를 <code>&quot;원본 S3 Bucket&quot;(unifest-original-images)</code>에 업로드한다.</li>
<li>S3에 객체가 생성되면, 설정된 트리거가 <code>Lambda 함수</code>를 실행한다.</li>
<li>이미지를 경량화하고, 완료되면 <code>&quot;경량화 S3 Bucket&quot;(unifest-optimized-images)</code>에 업로드한다.</li>
<li><code>Lambda</code>는 경량화 성공 후, <code>Spring 서버</code>의 POST /optimization API를 호출하여 경량화된 이미지 URL과 원본 이미지 URL을 전달하며 작업 완료를 알린다.</li>
<li><code>서버</code>는 알림을 받고, 원본 URL을 기준으로 <code>DB</code>를 색인하여 경량화된 이미지 URL로 업데이트한다.</li>
</ol>
</blockquote>
<p>이 구조를 통해 Spring 서버는 Lambda의 작업 완료 시점을 명확히 알 수 있으며, 정확한 최종 URL을 DB에 저장할 수 있게 된다.</p>
<h2 id="pillow-에러-troubleshooting">Pillow 에러 TroubleShooting</h2>
<p>테스트를 진행하던 중에 다음과 같은 import 오류가 지속적으로 발생함을 확인하였다.</p>
<blockquote>
<p>[ERROR] Runtime.ImportModuleError: Unable to import module 'lambda_function': cannot import name '<em>imaging' from 'PIL' (/var/task/PIL/_<em>init</em></em>.py)</p>
</blockquote>
<p>여러 테스트를 진행하며 로컬 환경(윈도우)에서 Pillow 라이브러리를 설치하고 zip 파일로 압축해 Lambda에 올렸는데, Lambda의 실행 환경은 리눅스 기반이라 호환성 문제가 발생한 것이라는 것을 알아냈다.</p>
<p>이에 대한 해결 방법은 두 가지가 있는 것으로 보인다.</p>
<h3 id="1-사전-빌드된-layer-사용-arn">1. 사전 빌드된 Layer 사용 (ARN)</h3>
<p>고맙게도 많은 개발자들이 AWS Lambda 환경에 맞춰 미리 패키지를 빌드하여 Layer로 제공하고 있다. Klayers 같은 곳에서 내 Lambda 환경에 맞는 ARN(Amazon Resource Name)을 찾아, Lambda 함수의 '계층(Layer) 추가' 기능으로 설정해주면 간단히 해결됩니다.</p>
<blockquote>
<p><strong>Klayers</strong> - 링크의 p3.12 라는 값을 변경하여 파이썬 버전을 조절할 수 있다.
<a href="https://api.klayers.cloud/api/v2/p3.12/layers/latest/ap-northeast-2/html">https://api.klayers.cloud/api/v2/p3.12/layers/latest/ap-northeast-2/html</a></p>
</blockquote>
<h3 id="2-호환되는-버전으로-직접-패키지-설치">2. 호환되는 버전으로 직접 패키지 설치</h3>
<p>만약 적절한 Layer가 없다면, 로컬에서부터 Lambda 실행 환경과 호환되는 버전으로 패키지를 설치해야 한다. 터미널에서 다음 명령어를 실행하여 리눅스 환경에 맞는 Pillow 패키지를 다운로드하고 다시 zip으로 압축하여 업로드하면 됩니다.</p>
<blockquote>
<p>pip install --platform manylinux2014_x86_64 --target=./my-pillow-layer/python/lib/python3.10/site-packages --python-version 3.10 --only-binary=:all: &quot;Pillow==11.3.0&quot;</p>
</blockquote>
<h2 id="기술-부채를-남기다">기술 부채를 남기다</h2>
<p>이미지 경량화란 뭘까... 마치 양파처럼 까면 깔수록 새로운 문제가 계속 나온다.
구현을 하다보니 DB에 색인을 하는 과정에 문제가 있음을 알게 되었다.</p>
<pre><code class="language-java">@Service
@RequiredArgsConstructor
@Transactional
public class ImgoptiService {

    private final BoothRepository boothRepository;
    private final FestivalRepository festivalRepository;
    private final HomeCardRepository homeCardRepository;
    private final MenuRepository menuRepository;
    private final SchoolRepository schoolRepository;
    private final StarRepository starRepository;

    public void optimizeImage(String preImgUrl, String postImgUrl){
        // Booth 관련 이미지 업데이트
        updateBoothImages(preImgUrl, postImgUrl);

        // Festival 관련 이미지 업데이트
        updateFestivalImages(preImgUrl, postImgUrl);

        // HomeCard 관련 이미지 업데이트
        updateHomeCardImages(preImgUrl, postImgUrl);

        // Menu 관련 이미지 업데이트
        updateMenuImages(preImgUrl, postImgUrl);

        // School 관련 이미지 업데이트
        updateSchoolImages(preImgUrl, postImgUrl);

        // Star 관련 이미지 업데이트
        updateStarImages(preImgUrl, postImgUrl);
    }

    // ... (각 Repository의 update 메서드들)
}</code></pre>
<p>그야말로 무식하고 끔찍한 코드이다..</p>
<p>Lambda가 보내준 preImgUrl(원본 URL)을 가지고 관련된 모든 테이블을 싹 다 뒤져서 postImgUrl(경량화 URL)로 업데이트하는 코드인데, 모든 테이블에서 해당 작업을 진행해야하므로 cost가 크다.</p>
<p>가장 이상적인 해결책은, 최초에 클라이언트가 이미지를 업로드할 때 어떤 엔티티(Booth, Menu 등)와 관련된 이미지인지, 해당 데이터의 id는 무엇인지 같은 메타데이터를 함께 보내주는 것으로 보인다. 이 정보를 Lambda까지 전달하면, 완료 알림 시 (entityType, entityId, preImgUrl, postImgUrl)을 다시 서버로 보내 DB 색인 과정을 단축하고 불필요한 검색을 제거할 수 있을 것이다.</p>
<p>하지만 현재 서비스 환경에서 이미지 업로드 기능은 부스 운영자가 부스를 등록할 때만 사용하는 등 사용 빈도가 매우 낮고(축제당 약 200건), 트래픽이 몰리는 기능도 아니다. 따라서 이 문제를 해결하기 위해 드는 리소스 대비 효용이 낮다고 판단하여, 일단 '기술 부채'로 남겨두기로 결정했다.</p>