<h2 id="문제-상황">문제 상황</h2>
<p>저번 유니페스 가천대 후기에서 남겼듯, 서비스 운영 중 FCM Token을 관리하던 Redis에서 SPoF(단일 실패 지점) 문제가 발생했다. 현장에서의 빠른 임기응변으로 급한 불은 껐지만, 임시방편은 언제나 기술 부채를 남긴다. 안정적인 서비스를 위해 이 문제를 근본적으로 해결해야 했다.</p>
<h3 id="해결-방법-1---db를-redis의-백업으로">해결 방법 1 - DB를 Redis의 백업으로</h3>
<p>가장 먼저 떠오른 생각은 임기응변 때와 마찬가지로 간단했다. &quot;Redis가 응답하지 않으면, DB에서 데이터를 가져오자.&quot; 캐싱의 기본 원칙처럼 Redis를 먼저 확인하고, 데이터가 null이라면 DB에 접근하는 방식으로 로직을 개선하기로 했다.</p>
<p>그런데 기존 코드를 살펴보니 고개를 갸웃하게 만드는, 기묘한 로직이 숨어있었다.
<img alt="" src="https://velog.velcdn.com/images/ysj7191/post/7bc5da3f-0d20-4e0b-b318-42066898dac4/image.png" /></p>
<blockquote>
<ol>
<li>웨이팅 호출 시, DB로부터 웨이팅 정보를 조회한다. (이때 저장된 fcmToken은 제외)</li>
<li>deviceId를 가지고 Redis에 다시 조회해서 fcmToken을 가져온다.</li>
<li>만약 Redis에 fcmToken이 없으면, <strong>다시 DB에 조회해서 fcmToken을 가져온다</strong>...???</li>
</ol>
</blockquote>
<p>백업을 위해 DB에 fcmToken을 저장하고 있는데
<strong>정작 처음 조회할 땐 그 정보를 무시하고 다시 Redis를 거쳐 DB로 돌아오는</strong> 모순적인 구조였다</p>
<p>즉, 애초에 Redis는 캐싱 역할을 하고 있지도 않았던 것이다.
필자는 <strong>캐싱 효과</strong>와 <strong>SPoF문제</strong>를 동시에 해결할 방법을 찾기로 했고, 따라서 다음과 같은 <strong>개선안</strong>을 도출했다.</p>
<h3 id="개선안">개선안<img alt="" src="https://velog.velcdn.com/images/ysj7191/post/680e4529-d3a5-4d95-8a3c-5c1e83c3216d/image.png" /></h3>
<blockquote>
<ol>
<li>기존 테이블의 fcmToken 컬럼을 제거하고 deviceId와 fcmToken을 매핑하는 FCM 테이블을 새로 생성한다. (제2 정규형 충족)</li>
<li>Redis의 데이터를 1시간에 한 번씩 FCM 테이블로 백업하는 스케줄러를 구현한다 -&gt; FCM 토큰의 불필요한 중복 업데이트 로직을 제거하고, DB를 온전한 백업 저장소로 활용할 수 있다.</li>
</ol>
</blockquote>
<p>&nbsp;</p>
<h3 id="개선안-2---문제-발생-시점에-해결하기">개선안 2 - 문제 발생 시점에 해결하기</h3>
<p>이 문제를 가지고 지인들과 이야기 하던 중 인사이트를 하나 얻을 수 있었다. 
&quot;데이터가 없을 때 백업을 찾는 것 뿐만 아니라, 데이터가 없을 때 다시 받으면 어떨까?&quot;</p>
<p>기존 로직의 핵심적인 문제점은, Redis에 fcmToken이 없으면 서버가 클라이언트(앱)에 문제가 있다고 통신할 방법이 없다는 것이었다.</p>
<p>그렇다면 사용자가 웨이팅 PIN 번호를 체크하는 바로 그 시점에 fcmToken의 유효성을 함께 확인하는 것이다.
로직은 다음과 같다.</p>
<blockquote>
<ol>
<li>사용자가 웨이팅 pin check를 진행한다</li>
<li>만약 이때 서버가 가진 토큰 값이 null이라면, 클라이언트에게 Status Code를 내려주어 토큰을 다시 등록하라는 요청을 보낸다.</li>
<li>사용자가 웨이팅 정보를 입력하는 동안, 앱은 백그라운드에서 <code>PUT /fcm-token API</code>를 호출해 새로운 토큰을 서버에 등록한다. </li>
</ol>
</blockquote>
<p><img alt="" src="https://velog.velcdn.com/images/ysj7191/post/e93f490d-18e4-4809-acc7-ea0d6bcbd824/image.png" />
※ 위 로직에서 문제가 될 수 있는 문제가 될 수 있는 반례는 <code>PUT /fcm-token</code> 요청을 보내고 처리가 되는 동안 웨이팅에 <strong>전화번호와 인원 수 기입, 약관 동의를 빛의 속도로 해버리는 경우</strong>가 아니라면 동기화 문제도 발생하지 않을 것으로 보인다.</p>
<h2 id="느낀-점">느낀 점</h2>
<p>급하게 땜빵했던 임기응변도 분명 의미가 있었지만, 그 한계를 느끼고 근본적인 해결책을 고민하는 것은 굉장히 난도 높은 일이었다. 마치 양파처럼, 문제를 파고들수록 계속해서 새롭게 고려할 요소들이 나타났다.</p>
<p>이번 경험을 통해 장애를 단순히 해결하는 것을 넘어, 장애가 발생하기 어려운 '구조'에 대한 고민의 중요성을 알게 되었다.</p>
<p>그러면서 가장 중요했던 것은 역시 <strong>'소통'</strong>이었다. 내 생각이 정말 맞는지, 더 나은 방법은 없는지, 로직에 숨겨진 허점은 없는지 끊임없이 팀원들과 대화하며 검증했다. </p>
<p>자신의 생각을 증명하고 신뢰도를 높이는 가장 좋은 방법은 결국 소통임을 다시 한번 느낄 수 있었다.</p>